# [658. æ‰¾åˆ° K ä¸ªæœ€æ¥è¿‘çš„å…ƒç´ ](https://leetcode.cn/problems/find-k-closest-elements/description/)

è¿™é“é¢˜å¯ä»¥ç”¨æ»‘åŠ¨çª—å£å†™ï¼Œç”¨åŒæŒ‡é’ˆä¼˜åŒ–ï¼Œæˆ‘è‡ªå·±å†™çš„æ—¶æ˜¯ç”¨çš„åŒæŒ‡é’ˆï¼Œä½†æ˜¯å†™çš„ç‰¹åˆ«åˆ«æ‰­ï¼Œä½†æ˜¯æ€è·¯è¿˜æ˜¯å¾ˆæ­£ç¡®çš„ï¼Œä¸‹é¢æ˜¯æˆ‘è‡ªå·±å†™çš„ä»£ç ,è¿˜ç”¨AIç”Ÿæˆäº†æ³¨é‡Šï¼Œçœå¾—ä»¥åçœ‹ä¸æ‡‚ğŸ˜‚ï¼ˆè™½ç„¶ç”¨AIæ”¹äº†å¥½å¤šéæ‰å†™å¯¹ï¼‰ï¼š

```cpp

class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        vector<int> res; // ç”¨äºå­˜å‚¨ç»“æœçš„æ•°ç»„
        int n = arr.size(); // æ•°ç»„çš„é•¿åº¦

        // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœ x å¤§äºç­‰äºæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ 
        if (arr[n - 1] <= x) {
            for (int i = n - k; i < n; ++i) // ç›´æ¥è¿”å›æœ€å k ä¸ªå…ƒç´ 
                res.push_back(arr[i]);
            return res; // è¿”å›ç»“æœ
        } 
        // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå¦‚æœ x å°äºç­‰äºæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        else if (arr[0] >= x) {
            for (int i = 0; i < k; ++i) // ç›´æ¥è¿”å›å‰ k ä¸ªå…ƒç´ 
                res.push_back(arr[i]);
            return res; // è¿”å›ç»“æœ
        } 
        else {
            // å‘å³æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äº x çš„å…ƒç´ çš„ç´¢å¼•
            int s = 0;
            while (s + 1 < n && arr[s + 1] <= x) // ç¡®ä¿ä¸å‡ºç•Œ
                s++;
            int l = s, r = s + 1; // å·¦æŒ‡é’ˆ l æŒ‡å‘ x å·¦ä¾§å…ƒç´ ï¼Œå³æŒ‡é’ˆ r æŒ‡å‘ x å³ä¾§å…ƒç´ 

            while (k) { // å½“éœ€è¦çš„å…ƒç´ ä¸ªæ•° k ä»ç„¶å¤§äº 0
                // å¦‚æœå·¦å³æŒ‡é’ˆéƒ½åœ¨èŒƒå›´å†…ï¼Œå¹¶ä¸” k ä»ç„¶å¤§äº 0
                if (l >= 0 && r < n && k > 0) {
                    // å¦‚æœå·¦ä¾§è·ç¦» x æ›´è¿‘æˆ–è€…ç›¸ç­‰
                    if (abs(arr[l] - x) <= abs(arr[r] - x)) {
                        res.push_back(arr[l--]); // é€‰æ‹©å·¦ä¾§å…ƒç´ ï¼Œå·¦æŒ‡é’ˆå‘å·¦ç§»åŠ¨
                    } 
                    else {
                        res.push_back(arr[r++]); // é€‰æ‹©å³ä¾§å…ƒç´ ï¼Œå³æŒ‡é’ˆå‘å³ç§»åŠ¨
                    }
                    k--; // å‡å°‘éœ€é€‰å…ƒç´ æ•°é‡
                }

                // å½“å·¦æŒ‡é’ˆè¶…å‡ºè¾¹ç•Œ
                if (l < 0 && r < n && k > 0) {
                    // åªå‰©å³ä¾§å…ƒç´ å¯é€‰
                    while (k) { // é€‰æ‹©å³ä¾§çš„ k ä¸ªå…ƒç´ 
                        res.push_back(arr[r++]); // é€‰å³ä¾§å…ƒç´ ï¼Œå³æŒ‡é’ˆå‘å³ç§»åŠ¨
                        k--;
                    }
                }

                // å½“å³æŒ‡é’ˆè¶…å‡ºè¾¹ç•Œ
                if (r >= n && l >= 0 && k > 0) {
                    // åªå‰©å·¦ä¾§å…ƒç´ å¯é€‰
                    while (k) { // é€‰æ‹©å·¦ä¾§çš„ k ä¸ªå…ƒç´ 
                        res.push_back(arr[l--]); // é€‰å·¦ä¾§å…ƒç´ ï¼Œå·¦æŒ‡é’ˆå‘å·¦ç§»åŠ¨
                        k--;
                    }
                }
            }
        }
        sort(res.begin(), res.end()); // æ’åºç»“æœæ•°ç»„ï¼ˆå› ä¸ºå¯èƒ½æ˜¯å€’åºåŠ å…¥çš„ï¼‰
        return res; // è¿”å›æœ€ç»ˆç»“æœ
    }
};

```

---

ä¸‹é¢æ˜¯AIå†™çš„ç®€æ´ä¸€ç‚¹çš„ç‰ˆæœ¬ï¼Œç¼©å‡äº†ä¸€äº›åˆ¤æ–­ï¼š

```cpp

class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        vector<int> res;
        int n = arr.size();
        
        // Edge cases
        if (arr[n - 1] <= x) {
            for (int i = n - k; i < n; ++i)
                res.push_back(arr[i]);
            return res;
        }
        if (arr[0] >= x) {
            for (int i = 0; i < k; ++i)
                res.push_back(arr[i]);
            return res;
        }

        // Find the split point where arr[s] <= x and arr[s+1] > x
        int s = 0;
        while (s < n - 1 && arr[s + 1] <= x)
            s++;
        
        int l = s, r = s + 1;
        
        // Collect k closest elements
        while (k > 0) {
            if (l < 0) {
                res.push_back(arr[r++]);
            } else if (r >= n) {
                res.push_back(arr[l--]);
            } else {
                if (abs(arr[l] - x) <= abs(arr[r] - x)) {
                    res.push_back(arr[l--]);
                } else {
                    res.push_back(arr[r++]);
                }
            }
            k--;
        }
        
        // Sort the result since elements were added out of order
        sort(res.begin(), res.end());
        return res;
    }
};

```

---

ä¸‹é¢æ˜¯å®˜æ–¹é¢˜è§£çš„ä»£ç ï¼Œæ€è·¯å’Œæˆ‘è‡ªå·±å†™çš„æ˜¯åŸºæœ¬ç›¸åŒçš„ï¼Œæ‰¾åˆ°å’Œ`x`æœ€è¿‘çš„é‚£ä¸ªæ•°å­—ï¼Œç„¶åæ¯”è¾ƒä¸¤è¾¹çš„æ•°ï¼Œä½†æ˜¯å®˜æ–¹çš„é¢˜è§£æ›´åŠ ç®€å•å¹¶ä¸”é«˜æ•ˆï¼Œæˆ‘è¿˜ç”¨AIç”Ÿæˆäº†æ³¨é‡Šï¼Œæ–¹ä¾¿ç†è§£,åŒæ—¶å®˜æ–¹é¢˜è§£
è¿˜ç”¨åˆ°äº†äºŒåˆ†æŸ¥æ‰¾åº“å‡½æ•°[lower_bound](../../åº“å‡½æ•°%20&%20æ‰©å±•çŸ¥è¯†/lower_bound.md)ï¼Œå¯ä»¥é•¿é•¿è§è¯†ï¼Œä»¥åç¢°åˆ°ç±»ä¼¼çš„é¢˜å¯ä»¥å°‘äº›ä¸€ç‚¹ä»£ç ğŸ˜

```cpp

class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        // ä½¿ç”¨ lower_bound æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸å°äº x çš„å…ƒç´ çš„ç´¢å¼•
        // è¿™ä¸€æ­¥å¯ä»¥å¿«é€Ÿå®šä½ x åœ¨æ•°ç»„ä¸­çš„å¤§è‡´ä½ç½®
        int right = lower_bound(arr.begin(), arr.end(), x) - arr.begin();
        
        // å°† left æŒ‡é’ˆåˆå§‹åŒ–ä¸º right çš„å·¦ä¾§ä¸€ä¸ªä½ç½®
        int left = right - 1;

        // ç”¨äºé€‰å– k ä¸ªæœ€æ¥è¿‘ x çš„å…ƒç´ 
        while (k--) {
            if (left < 0) {
                // å¦‚æœ left è¶…å‡ºæ•°ç»„å·¦è¾¹ç•Œï¼Œåªèƒ½é€‰æ‹©å³è¾¹å…ƒç´ 
                right++;
            } else if (right >= arr.size()) {
                // å¦‚æœ right è¶…å‡ºæ•°ç»„å³è¾¹ç•Œï¼Œåªèƒ½é€‰æ‹©å·¦è¾¹å…ƒç´ 
                left--;
            } else if (x - arr[left] <= arr[right] - x) {
                // å¦‚æœå·¦ä¾§å…ƒç´ ä¸ x çš„è·ç¦»å°äºç­‰äºå³ä¾§å…ƒç´ 
                // ä¼˜å…ˆé€‰æ‹©å·¦ä¾§å…ƒç´ 
                left--;
            } else {
                // å¦‚æœå³ä¾§å…ƒç´ æ›´æ¥è¿‘ xï¼Œåˆ™é€‰æ‹©å³ä¾§å…ƒç´ 
                right++;
            }
        }

        // æœ€ç»ˆè¿”å›ä» (left + 1) åˆ° (right) çš„è¿™æ®µå…ƒç´ 
        // å› ä¸º left å¯èƒ½å·¦ç§»è¶Šç•Œï¼Œæ‰€ä»¥ä» left + 1 å¼€å§‹
        return vector<int>(arr.begin() + left + 1, arr.begin() + right);
    }
};

```
