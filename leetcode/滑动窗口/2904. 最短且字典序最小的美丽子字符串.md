# [2904. 最短且字典序最小的美丽子字符串](https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/)

滑动窗口题，我自己写的思路就是按照模板写，然后找到每个符合条件的子串时都判断一遍长度和大小，直到找出最终结果，但是我写的时候一直出问题。下面是我看灵神[视频](https://www.bilibili.com/video/BV1aC4y1G7dB/?vd_source=5c3d41684bdf5be095ecc932cc1b67b8)
和题解自己所学到的知识

首先是暴力方法，下面是代码：

```cpp

class Solution {
public:
    string shortestBeautifulSubstring(string s, int k) {
        // 1. 统计字符串 s 中 '1' 的总数
        int cnt1 = 0;
        for (char c : s) {
            if (c == '1')
                cnt1++;
        }

        // 2. 如果字符串中 '1' 的总数小于 k，直接返回空字符串
        if (cnt1 < k)
            return "";

        // 3. 尝试从长度为 k 开始，逐步增加子字符串的长度，直到整个字符串的长度
        for (int size = k; size <= s.length(); ++size) {
            string ans = ""; // 用于存储当前找到的最优子字符串

            // 4. 遍历所有长度为 size 的子字符串
            for (int i = size - 1; i < s.length(); ++i) {
                // 5. 提取从 i - size + 1 到 i 的子字符串
                string str = s.substr(i - size + 1, size);

                // 6. 统计当前子字符串中 '1' 的数量
                int cnt = 0;
                for (char c : str)
                    if (c == '1')
                        cnt++;

                // 7. 如果当前子字符串满足恰好有 k 个 '1'，且比当前 ans 更优
                // （要么 ans 为空，要么 str 的字典序更小）
                if ((ans == "" || ans > str) && cnt == k)
                    ans = str; // 更新 ans 为当前子字符串
            }

            // 8. 如果在当前长度 size 找到了符合条件的子字符串，直接返回
            if (ans != "")
                return ans;
        }

        // 9. 如果没有任何长度下找到符合条件的子字符串，返回空字符串
        return "";
    }
};

```
- 该算法通过逐步增加子字符串的长度，从 k 开始，直到整个字符串的长度，来寻找最短的包含 k 个 '1' 的子字符串。
- 在每个固定的长度下，遍历所有可能的子字符串，统计其中 '1' 的数量，并更新最优答案。
- 如果找到了符合条件的子字符串，直接返回；如果遍历完所有可能的情况都没有找到，返回空字符串。
- 时间复杂度是 $O(N^2)$，空间复杂度是 $O(N)$，因为使用了 `substr`，导致产生额外空间


