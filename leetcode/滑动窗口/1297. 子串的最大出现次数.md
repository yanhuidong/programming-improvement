# [1297. å­ä¸²çš„æœ€å¤§å‡ºç°æ¬¡æ•°](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/description/)

åˆæ˜¯ä¸€åœºé…£ç•…æ·‹æ¼“çš„æˆ˜æ–—å•Šï¼Œæˆ‘åˆä¸€æ¬¡è¢«æ‰“è´¥äº†ï¼Œå…„å¼Ÿä»¬ï¼Œè¿™é“é¢˜æ˜¯æˆ‘æ‹¼å°½å…¨åŠ›ä¹Ÿæ— æ³•æˆ˜èƒœçš„æ•Œäººå•ŠğŸ˜‚ï¼Œè™½ç„¶æ˜¯æœ‰æ€è·¯çš„ï¼Œè€Œä¸”ä¹Ÿç®—æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯å°±æ˜¯ä¸çŸ¥é“æ€ä¹ˆå»å†™ï¼Œè„‘ç“œå­å—¡å—¡çš„ï¼Œè¿˜æ˜¯æ²¡å®åŠ›å•Šï¼Œ
ä¸‹é¢æ˜¯æˆ‘æŠŠåˆ«äººçš„Javaé¢˜è§£ç”¨GPTè½¬æˆçš„C++çš„ä»£ç ï¼Œè‡ªå·±çœ‹å»å§ï¼š

```cpp

class Solution {
public:
    int maxFreq(std::string s, int maxLetters, int minSize, int maxSize) {
        int n = s.length();
        // ç”¨unordered_mapè®°å½•å­ä¸²å‡ºç°çš„é¢‘ç‡
        std::unordered_map<std::string, int> map;
        // å­—ç¬¦æ•°ç»„
        std::vector<int> count(128, 0);  // ç”¨äºè®°å½•å­—ç¬¦çš„é¢‘æ¬¡ï¼Œ128æ˜¯å› ä¸ºASCIIç çš„èŒƒå›´
        int left = 0, right = 0, tmp = 0; // tmpè®°å½•å½“å‰çª—å£å†…ä¸åŒå­—æ¯çš„æ•°é‡
        int ans = 0;  // æœ€ç»ˆç»“æœï¼Œæœ€å¤§å‡ºç°æ¬¡æ•°
        
        while (right < n) {
            // æ‰©å±•çª—å£
            count[s[right]]++;
            // å¦‚æœå½“å‰å­—ç¬¦å‡ºç°æ¬¡æ•°ä¸º1ï¼Œè¯´æ˜æ˜¯ä¸€ä¸ªæ–°çš„ä¸åŒå­—ç¬¦
            if (count[s[right]] == 1) tmp++;
            right++;

            // çª—å£çš„é•¿åº¦
            int len = right - left;

            // å¦‚æœçª—å£å†…çš„ä¸åŒå­—æ¯æ•°å¤§äºmaxLettersæˆ–è€…çª—å£é•¿åº¦å¤§äºminSizeï¼Œå·¦ä¾§æ”¶ç¼©çª—å£
            while (tmp > maxLetters || len > minSize) {
                count[s[left]]--;
                if (count[s[left]] == 0) tmp--;
                left++;
                len--;
            }

            // å¦‚æœæ»¡è¶³æ¡ä»¶ï¼ˆä¸åŒå­—æ¯æ•°å°äºç­‰äºmaxLettersï¼Œä¸”çª—å£é•¿åº¦ç­‰äºminSizeï¼‰ï¼Œå°±ç»Ÿè®¡è¯¥å­ä¸²
            if (tmp <= maxLetters && len == minSize) {
                std::string str = s.substr(left, minSize);
                map[str]++;
            }
        }

        // æ‰¾åˆ°å‡ºç°æ¬¡æ•°æœ€å¤šçš„å­ä¸²
        for (const auto& entry : map) {
            ans = std::max(ans, entry.second);
        }
        return ans;
    }
};
```

è¿˜æ˜¯ä¸€å¥è¯ï¼Œèœå°±å¤šç»ƒã€‚

---

å¤ªå¥½äº†ï¼Œé€šè¿‡æˆ‘çš„ä¸æ‡ˆåŠªåŠ›ï¼Œæˆ‘è‡ªå·±åˆé€šè¿‡ä¸Šé¢è¿™æ®µä»£ç ä¿®æ”¹æˆäº†ç¬¦åˆæ»‘åŠ¨çª—å£æ ·å¼çš„é¢˜è§£ï¼Œè™½ç„¶èŠ±äº†ä¸å°‘æ—¶é—´ï¼Œä½†æ˜¯è¿˜å­¦ä¹ åˆ°äº†[erase]()è¿™ä¸ªåº“å‡½æ•°çš„ç”¨æ³•ï¼Œæ„Ÿè§‰è¿˜æ˜¯å¾ˆæœ‰æˆå°±æ„Ÿçš„ï¼Œä¸‹é¢æ˜¯æˆ‘è‡ªå·±å†™çš„ä»£ç ï¼š

```cpp

class Solution {
public:
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        unordered_map<string, int> map;
        int ans = 0, tmp = 0;
        int n = s.length();
        string pre = "";
        vector<int> check(26, 0);
        for (int i = 0; i < minSize; ++i) {
            pre += s[i];
            check[s[i] - 'a'] ++;
            if (check[s[i] - 'a'] == 1) 
                tmp ++;
            
            if (tmp <= maxLetters && pre.length() == minSize) {
                map[pre] ++;
            }
        }

        for (int i = minSize; i < n; ++i) {
            pre.erase(pre.begin(), pre.begin() + 1);
            if (check[s[i - minSize] - 'a'] == 1)
                tmp --;
            check[s[i - minSize] - 'a'] --;
            check[s[i] - 'a'] ++;
            if (check[s[i] - 'a'] == 1)
                tmp ++;
            pre += s[i];

            if (tmp <= maxLetters)
                map[pre] ++;
        }

        for (const auto& c : map) {
            ans = max(ans, c.second);
        }
        return ans;
    }
};
```

---

ä¸‹é¢æ˜¯GPTä¼˜åŒ–åçš„æˆ‘çš„ä»£ç ï¼Œå˜å¾—æ›´ç®€æ´äº†ï¼Œè™½ç„¶æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦éƒ½æ²¡å’‹å˜å°±æ˜¯äº†ï¼Œä½†è‡³å°‘çœ‹ç€èˆ’æœï¼š

```cpp

class Solution {
public:
    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {
        unordered_map<string, int> map;
        int ans = 0;
        int n = s.length();
        vector<int> check(26, 0);
        int tmp = 0;

        for (int i = 0; i < minSize; ++i) {
            check[s[i] - 'a']++;
            if (check[s[i] - 'a'] == 1) tmp++;
        }

        for (int i = minSize; i <= n; ++i) {
            if (i > minSize) {
                check[s[i - minSize - 1] - 'a']--;
                if (check[s[i - minSize - 1] - 'a'] == 0) tmp--;
                check[s[i - 1] - 'a']++;
                if (check[s[i - 1] - 'a'] == 1) tmp++;
            }
            
            if (tmp <= maxLetters) {
                string sub = s.substr(i - minSize, minSize);
                map[sub]++;
                ans = max(ans, map[sub]);
            }
        }

        return ans;
    }
};
```
